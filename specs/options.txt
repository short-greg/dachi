# Lens Sales Forecasting System — Architecture Options (v0.1)

> Role: Senior solutions architect & data/ML platform strategist (Snowflake, AWS, Google Workspace)
>
> Scope: Decision-ready options for a monthly, national **Lens Sales Forecasting** system with swappable subsystems (UI, orchestration, modeling/ML, storage, serving).

---

## 1) Executive Summary (≤1 page)

**Recommendation (shortlist):**

**A. Snowflake‑first App (Streamlit‑in‑Snowflake + Snowflake ML Forecasting)**

* *Why*: Fastest time‑to‑first‑value; minimal ops; governed data stays in Snowflake; built‑in forecasting produces point + interval outputs; Streamlit delivers an interactive chart with lens‑type selector; Sheets/CSV export via app actions; governance via roles, masking & tags.

**B. Snowflake App + Containerized Models (SPCS) + Forecast Table**

* *Why*: Retains Snowflake‑centric UX while letting you run custom models (e.g., hierarchical TS, probabilistic) in **Snowpark Container Services**; writeback to forecast tables; same UI/permissions.

**C. AWS SageMaker Pipeline + Snowflake Data + SPA (S3/CloudFront)**

* *Why*: If you need bespoke ML workflows, AutoML/experiments at scale, or future MLOps standardization in AWS. Snowflake remains system of record; SPA or QuickSight provides dashboarding.

**Thumbnail diagrams**

```mermaid
flowchart LR
  subgraph A[Candidate A: Snowflake-first]
    Sheets[(Sheets)]-->App
    App[[Streamlit in Snowflake]]--SQL/Snowpark-->SF[(Snowflake)]
    SF--Tasks/Dyn Tables-->SF
    SF--Forecasts-->App
  end
```

```mermaid
flowchart LR
  subgraph B[Candidate B: SF App + SPCS]
    App[[Streamlit in SF]]-->SF[(Snowflake)]
    SF--Features-->SPCS[/Container Service/]
    SPCS--Forecasts-->SF
    SF-->App
  end
```

```mermaid
flowchart LR
  subgraph C[Candidate C: AWS SageMaker + SPA]
    SF[(Snowflake)]<--Bulk/ODBC-->SM[SageMaker]
    SM--Forecast Writeback-->SF
    SPA[[SPA S3/CloudFront]]--Query-->API[(API GW+Lambda)]--Connector-->SF
  end
```

**Why A > B > C now:** A meets must‑haves with the least ops and tightest governance. B unlocks advanced modeling without leaving Snowflake. C is best when AWS‑centric ML governance or specialized model families are a priority.

**What changes for regional/weekly variants?**

* Add region dimension to series key and/or increase frequency to weekly. Ensure *features* and calendar/promotions tables support the granularity; scale training with multi‑series training and partitioned jobs; consider hierarchical reconciliation for region→national.

---

## 2) Option Catalog (≥12 architectures)

> Grouped by UI / orchestration / modeling / serving. Each option lists: Context, Data Flow, Sequence (Mermaid), Components, Decision levers, Pros/Cons, Risks, Rough cost & ops, When to choose, Exit ramps.

### Legend (used across diagrams)

* **UI**: Sheets Add‑on, Streamlit (Snowflake), SPA (S3/CloudFront), AppSheet, Retool, QuickSight, Snowsight dashboard
* **Orchestration**: Snowflake Tasks/Streams/Dynamic Tables, SPCS Jobs, Lambda + Step Functions, GitHub Actions
* **Modeling**: Snowflake ML Forecasting, Snowpark (Python) UDF/UDTF, SPCS container, SageMaker, dbt‑python (Snowpark)
* **Serving**: Forecast table in Snowflake + secure views; API (API GW + Lambda); External Functions; Snowsight/Streamlit charts

---

### Option 1 — **Snowflake‑first: Streamlit‑in‑Snowflake + Snowflake ML Forecasting**

**Context:** Min‑ops, fast delivery; all compute & data inside Snowflake.

**Data Flow**

```mermaid
flowchart LR
  Raw-->Feat[Dynamic Tables & Views]
  Feat-->Train[CREATE SNOWFLAKE.ML.FORECAST]
  Train-->FC[FORECAST() -> forecast_table]
  FC-->App[[Streamlit in Snowflake]]
  App-->User
```

**Sequence**

```mermaid
sequenceDiagram
  participant U as User
  participant App as Streamlit App
  participant SF as Snowflake
  U->>App: Select lens type, month range
  App->>SF: SQL query (secure view) + call model!FORECAST if needed
  SF-->>App: Series, forecast, lower/upper
  App-->>U: Dynamic chart + CSV export
```

**Components:** Streamlit app; Snowflake Tasks/Dynamic Tables; **SNOWFLAKE.ML.FORECAST**; forecast table + secure views.

**Decision levers:** batch (scheduled) vs on‑demand `!FORECAST`; caching via materialized view; monthly granularity.

**Pros:** Minimal infra, governed data, intervals first‑class; quick to ship.

**Cons/Risks:** Some Streamlit‑in‑Snowflake limitations (component support, data transmission caps); algorithm control is limited; complex UIs may outgrow Streamlit.

**Rough Cost/Ops:** OPEX **Low–Med** (warehouse time + task schedule); Ops **Low**; TTFV **Fast**.

**When to choose:** Need value in weeks; analysts live in SQL; lens types evolve.

**Exit ramps:** Swap modeling to SPCS (Option 2) keeping UI & tables; or expose REST API (Option 6).

---

### Option 2 — **Snowflake App + Snowpark Container Services (SPCS) Models**

**Context:** Same UX as Opt.1; custom containers for hierarchical TS, probabilistic (e.g., Prophet w/ uncertainty, NGBoost).
**Flow**

```mermaid
flowchart LR
  Feat[Feature Views]-->SPCS[/Container Job: Train/Score/]
  SPCS-->FC[(Forecast Table)]
  FC-->App[[Streamlit in SF]]
```

**Sequence**

```mermaid
sequenceDiagram
  participant Task as SF Task
  participant SPCS as Container Job
  Task->>SPCS: Run training/backtest
  SPCS->>SPCS: Log metrics, artifacts
  SPCS->>SF: MERGE into forecast_table
  App->>SF: Query forecasts
```

**Pros:** Full model control; Python/R libs; GPU if needed; future‑proof.

**Cons:** Higher ops than Opt.1; container lifecycle; quotas/limits.

**Rough Cost/Ops:** OPEX **Med** (compute pools) ; Ops **Med**; TTFV **Medium**.

**When:** Need custom methods, hierarchical reconciliation, quantiles beyond built‑in.

**Exit:** Move training to SageMaker (Opt.10/11) or switch UI to SPA (Opt.7) with same storage.

---

### Option 3 — **Snowflake UDF/UDTF (Snowpark Python) + Streamlit UI**

**Context:** Implement forecasting as Python UDF/UDTF; keep logic near data.

**Flow**

```mermaid
flowchart LR
  SF[(Snowflake)]--Snowpark UDTF-->FC[(Forecast Table)]
  FC-->UI[[Streamlit in SF]]
```

**Pros:** Custom but still inside Snowflake; governed dependencies via Anaconda.

**Cons:** Package/size limits; long runs better as SPCS; dev experience vs Opt.2.

**Rough Cost/Ops:** OPEX **Low–Med**; Ops **Low–Med**; TTFV **Medium**.

**When:** Moderate customization; avoid containers.

---

### Option 4 — **Snowsight Dashboards + Forecast Views**

**Context:** No separate app; use Snowsight worksheets/dashboards for charts & filters.

**Flow/Seq**

```mermaid
flowchart LR
  FC[(Forecast Table)]-->Snowsight[[Snowsight Dashboards]]
  Snowsight-->Users
```

```mermaid
sequenceDiagram
  User->>Snowsight: Filter lens type
  Snowsight->>SF: Query secure view
  SF-->>Snowsight: Results
```

**Pros:** Zero deployment; governed; good for internal users.

**Cons:** Less branded UX; fewer export/print niceties; limited interactivity vs Streamlit.

**Rough Cost/Ops:** OPEX **Low**; Ops **Very Low**; TTFV **Fast**.

**When:** Internal pilot, analyst audience.

---

### Option 5 — **Sheets‑Driven UI + Snowflake API (Lambda)**

**Context:** Keep Sheets ergonomics; Apps Script menu calls an API to fetch/write forecasts.

**Flow/Seq**

```mermaid
flowchart LR
  Sheets[[Google Sheets Add-on]]--HTTP-->API[(API GW+Lambda)]--ODBC/Python-->SF
  SF-->API-->Sheets
```

**Pros:** Meets users where they live; easy CSV/print; simple auth via Google.

**Cons:** Add‑on development; concurrency & quota mgmt; testing complexity.

**Rough Cost/Ops:** OPEX **Low**; Ops **Low–Med**; TTFV **Medium**.

**When:** Analysts prefer Sheets first; MVP export/print is key.

---

### Option 6 — **Headless API + SPA (S3/CloudFront)**

**Context:** Decouple UI; REST API queries Snowflake; SPA renders interactive charts.

**Flow**

```mermaid
flowchart LR
  SPA[[React/Vue SPA]]--->API[(API GW+Lambda)]--->SF[(Snowflake)]
  SF--->API--->SPA
```

**Pros:** Rich UX, fine control; scalable; can later add mobile.

**Cons:** More moving parts; IAM across clouds.

**Rough Cost/Ops:** OPEX **Med**; Ops **Med**; TTFV **Medium**.

**When:** Productized UX; broader audience; want A/B tests & telemetry.

---

### Option 7 — **QuickSight + Snowflake (Direct)**

**Context:** BI via Amazon QuickSight with Snowflake connector; dashboards & exports.

**Flow**

```mermaid
flowchart LR
  SF[(Snowflake)]-->QS[[QuickSight Dashboards]]-->Users
```

**Pros:** Serverless BI; scheduled refresh; export/print; row‑level security.

**Cons:** Separate IAM/SSO setup; dashboarding not app‑like; cost per reader.

**Rough Cost/Ops:** OPEX **Low–Med** (per‑reader); Ops **Low**; TTFV **Fast**.

**When:** Org already standardized on QuickSight; need pixel‑perfect print.

---

### Option 8 — **Looker Studio via Connector + Snowflake**

**Context:** Use a partner/community Snowflake connector to Looker Studio for lightweight dashboards; Sheets extracts optional.

**Flow**

```mermaid
flowchart LR
  SF[(Snowflake)]-->LS[[Looker Studio]]
  SF-->Sheets[(Sheets extracts)]
```

**Pros:** Familiar Google UX; embeds; easy sharing.

**Cons:** Connector limits; performance vs large data; governance via connector vendor.

**Rough Cost/Ops:** OPEX **Low** (connector fees may apply); Ops **Low**; TTFV **Fast**.

**When:** Light analytics in Google ecosystem; simple slicers.

---

### Option 9 — **AppSheet + Snowflake (Connector)**

**Context:** No‑code CRUD & viewer over forecast tables with lens selectors.

**Pros:** Very fast internal tools; mobile‑friendly.

**Cons:** Not ideal for heavy charts; connector/licensing; less custom viz control.

**Rough Cost/Ops:** OPEX **Low**; Ops **Very Low**; TTFV **Fast**.

**When:** Simple forms + lookups; small audience ops tools.

---

### Option 10 — **SageMaker Pipelines + Batch Transform; UI = SPA**

**Context:** AWS‑native MLOps; training & backtesting in SageMaker; writeback to Snowflake; SPA consumes forecasts.

**Flow**

```mermaid
flowchart LR
  SF[(Snowflake)]<--Bulk Copy-->SM[SageMaker Pipelines]
  SM--Writeback-->SF
  SPA[[SPA]]--->API[(API GW+Lambda)]--->SF
```

**Pros:** Advanced experiments, autotuning, registries; bring your probabilistic libs.

**Cons:** Most ops; extra IAM; data egress; cost.

**Rough Cost/Ops:** OPEX **Med–High**; Ops **High**; TTFV **Slower**.

**When:** Heavy ML team; AWS standardization.

---

### Option 11 — **SageMaker (Canvas/Autopilot) + QuickSight**

**Context:** Low‑code forecasting in Canvas/Autopilot; write results to Snowflake; consume in QuickSight.

**Pros:** Very fast for non‑coders; BI built‑in.

**Cons:** Less reproducible than code; portability.

**Rough Cost/Ops:** OPEX **Low–Med**; Ops **Low**; TTFV **Fast**.

**When:** Business‑led experiments; short‑lived projects.

---

### Option 12 — **dbt + Snowpark Py models + Snowsight/Streamlit**

**Context:** Treat feature engineering & Python models as dbt nodes (SQL + Python); schedule via Snowflake Tasks; viz in Snowsight or Streamlit.

**Pros:** Strong lineage; CI in dbt; unified DAG.

**Cons:** Python model ergonomics improving; long‑running jobs better as SPCS.

**Rough Cost/Ops:** OPEX **Low–Med**; Ops **Med**; TTFV **Medium**.

**When:** Team already on dbt; want lineage & tests.

---

### Option 13 — **External Function to Lambda Scoring + Streamlit**

**Context:** Call AWS Lambda from Snowflake via External Functions to score on‑demand; keep forecasts in a table.

**Pros:** Reuse existing AWS models; simple serverless path.

**Cons:** Latency; payload size/timeout constraints; IAM plumbing.

**Rough Cost/Ops:** OPEX **Low–Med**; Ops **Med**; TTFV **Medium**.

**When:** Small scoring logic already lives in Lambda.

---

### Option Comparison (capsule ratings)

| #  | Fit to must‑haves | Time‑to‑first‑value | OPEX     | Ops burden | Maintainability | Lock‑in risk |
| -- | ----------------- | ------------------- | -------- | ---------- | --------------- | ------------ |
| 1  | High              | Fast                | Low–Med  | Low        | High            | Low–Med      |
| 2  | High              | Medium              | Med      | Med        | High            | Low          |
| 3  | High              | Medium              | Low–Med  | Low–Med    | Med             | Low–Med      |
| 4  | Med               | Fast                | Low      | Very Low   | Med             | Low          |
| 5  | High              | Medium              | Low      | Low–Med    | Med             | Low          |
| 6  | High              | Medium              | Med      | Med        | High            | Low          |
| 7  | Med–High          | Fast                | Low–Med  | Low        | Med             | Low–Med      |
| 8  | Med               | Fast                | Low      | Low        | Low–Med         | Med          |
| 9  | Med               | Fast                | Low      | Very Low   | Low–Med         | Med          |
| 10 | High              | Slower              | Med–High | High       | High            | Low          |
| 11 | Med               | Fast                | Low–Med  | Low        | Med             | Med          |
| 12 | High              | Medium              | Low–Med  | Med        | High            | Low          |
| 13 | Med               | Medium              | Low–Med  | Med        | Med             | Low          |

---

## 3) Subsystem Swap Matrix

> Rows = Options (1–13). Columns = UI, Job Orchestration, Feature Engineering, Model Training, Forecast Storage, API/Serving, Viz/Reporting, Identity/Auth. Each cell shows 1–3 viable implementations (within the client stack).

| #  | UI                  | Orchestration         | Feature Eng. | Model Training           | Forecast Storage | API/Serving       | Viz/Reporting       | Identity/Auth                  |
| -- | ------------------- | --------------------- | ------------ | ------------------------ | ---------------- | ----------------- | ------------------- | ------------------------------ |
| 1  | Streamlit (SF)      | SF Tasks/Dyn Tables   | SQL + Views  | SNOWFLAKE.ML.FORECAST    | Snowflake table  | Secure Views      | Streamlit chart     | Snowflake SSO                  |
| 2  | Streamlit (SF)      | Tasks + SPCS Jobs     | SQL + Views  | SPCS containers          | Snowflake table  | Views/UDFs        | Streamlit           | Snowflake SSO                  |
| 3  | Streamlit (SF)      | Tasks                 | SQL + UDTF   | Snowpark UDF/UDTF        | Snowflake table  | Views             | Streamlit           | Snowflake SSO                  |
| 4  | Snowsight           | Tasks/Dyn Tables      | SQL          | n/a (pre‑computed)       | Snowflake table  | Views             | Snowsight           | Snowflake SSO                  |
| 5  | Sheets Add‑on       | Step Functions/Lambda | SQL in SF    | SNOWFLAKE.ML or ext. API | Snowflake table  | API GW+Lambda     | Sheets charts       | Google SSO + Snowflake OAuth   |
| 6  | SPA                 | Step Functions        | SQL          | SPCS or SM               | Snowflake table  | API GW+Lambda     | SPA libs            | Cognito + Snowflake Ext. OAuth |
| 7  | QuickSight          | QS Schedules          | SQL          | Any (pre‑computed)       | Snowflake table  | Direct connector  | QuickSight          | AWS SSO + Snowflake OAuth      |
| 8  | Looker Studio       | AppScript refresh     | SQL          | Any (pre‑computed)       | Snowflake table  | Partner connector | Looker Studio       | Google SSO                     |
| 9  | AppSheet            | AppSheet sched.       | SQL          | Any (pre‑computed)       | Snowflake table  | Connector         | AppSheet views      | Google SSO                     |
| 10 | SPA                 | StepFn + SM Pipelines | SQL          | SageMaker                | Snowflake table  | API GW+Lambda     | SPA                 | Cognito + Snowflake Ext. OAuth |
| 11 | QuickSight          | QS Schedules          | SQL          | Canvas/Autopilot         | Snowflake table  | Direct connector  | QuickSight          | AWS SSO + Snowflake OAuth      |
| 12 | Streamlit/Snowsight | Tasks + dbt           | dbt SQL + Py | dbt Py (Snowpark)        | Snowflake table  | Views             | Streamlit/Snowsight | Snowflake SSO                  |
| 13 | Streamlit           | Tasks                 | SQL          | Lambda (ext fn)          | Snowflake table  | External Function | Streamlit           | Snowflake SSO                  |

> Rows = Options (1–13). Columns = UI, Job Orchestration, Feature Engineering, Model Training, Forecast Storage, API/Serving, Viz/Reporting, Identity/Auth. Each cell shows 1–3 viable implementations (within the client stack).

| #  | UI                  | Orchestration         | Feature Eng. | Model Training           | Forecast Storage | API/Serving       | Viz/Reporting       | Identity/Auth                  |
| -- | ------------------- | --------------------- | ------------ | ------------------------ | ---------------- | ----------------- | ------------------- | ------------------------------ |
| 1  | Streamlit (SF)      | SF Tasks/Dyn Tables   | SQL + Views  | SNOWFLAKE.ML.FORECAST    | Snowflake table  | Secure Views      | Streamlit chart     | Snowflake SSO                  |
| 2  | Streamlit (SF)      | Tasks + SPCS Jobs     | SQL + Views  | SPCS containers          | Snowflake table  | Views/UDFs        | Streamlit           | Snowflake SSO                  |
| 3  | Streamlit (SF)      | Tasks                 | SQL + UDTF   | Snowpark UDF/UDTF        | Snowflake table  | Views             | Streamlit           | Snowflake SSO                  |
| 4  | Snowsight           | Tasks/Dyn Tables      | SQL          | n/a (pre‑computed)       | Snowflake table  | Views             | Snowsight           | Snowflake SSO                  |
| 5  | Sheets Add‑on       | Step Functions/Lambda | SQL in SF    | SNOWFLAKE.ML or ext. API | Snowflake table  | API GW+Lambda     | Sheets charts       | Google SSO + Snowflake OAuth   |
| 6  | SPA                 | Step Functions        | SQL          | SPCS or SM               | Snowflake table  | API GW+Lambda     | SPA libs            | Cognito + Snowflake Ext. OAuth |
| 7  | QuickSight          | QS Schedules          | SQL          | Any (pre‑computed)       | Snowflake table  | Direct connector  | QuickSight          | AWS SSO + Snowflake OAuth      |
| 8  | Looker Studio       | AppScript refresh     | SQL          | Any (pre‑computed)       | Snowflake table  | Partner connector | Looker Studio       | Google SSO                     |
| 9  | AppSheet            | AppSheet sched.       | SQL          | Any (pre‑computed)       | Snowflake table  | Connector         | AppSheet views      | Google SSO                     |
| 10 | SPA                 | StepFn + SM Pipelines | SQL          | SageMaker                | Snowflake table  | API GW+Lambda     | SPA                 | Cognito + Snowflake Ext. OAuth |
| 11 | QuickSight          | QS Schedules          | SQL          | Canvas/Autopilot         | Snowflake table  | Direct connector  | QuickSight          | AWS SSO + Snowflake OAuth      |
| 12 | Streamlit/Snowsight | Tasks + dbt           | dbt SQL + Py | dbt Py (Snowpark)        | Snowflake table  | Views             | Streamlit/Snowsight | Snowflake SSO                  |
| 13 | Streamlit           | Tasks                 | SQL          | Lambda (ext fn)          | Snowflake table  | External Function | Streamlit           | Snowflake SSO                  |

*Identity/Auth choices*: Snowflake SSO w/ Google (SAML/OAuth), AWS Cognito + OIDC to Google, QuickSight OAuth to Snowflake, programmatic access tokens for service users.

---

## 4) Snowflake Capabilities Deep Dive (what we’ll leverage)

> **Note:** Citations & links are listed in the accompanying “References & Research Notes” section (chat).

* **Time‑Series Forecasting in‑database (SNOWFLAKE.ML.FORECAST)**: multi‑series training; lower/upper bounds & prediction intervals; *method*=`best` (ensemble) or `fast` (GBM); exogenous features allowed; forecast via `<model>!FORECAST`.
* **Snowpark (Python/Scala/Java) & UDF/UDTF**: implement custom transforms & scoring close to data; governed packages via Anaconda.
* **Snowpark Container Services (SPCS)**: train/serve arbitrary containers; GPU/CPU pools; managed networking and secrets.
* **Tasks, Streams & Dynamic Tables**: orchestration, CDC, and incremental pipelines completely in Snowflake UI; monitor via ACCOUNT\_USAGE.
* **Snowsight + Streamlit in Snowflake**: secure, native apps for interactive dashboards; Git integration & multi‑page; some component limitations and 32‑MB message cap.
* **External Functions & External Access**: call out to AWS Lambda for scoring & integrations when needed.
* **Feature Store & Model Registry** (Snowflake ML): standardize feature computation & reuse; track models and lineage.
* **Vector Indexing / Cortex Search**: optional for semantic item taxonomy or metadata search.
* **Governance (Horizon)**: Row Access Policies, Tag‑based Masking, Object Tagging; Account Usage views; Resource Monitors; Alerts.

**Top candidate mappings**

* *A*: SNOWFLAKE.ML.FORECAST, Tasks/Dynamic Tables, Streamlit in SF, secure views, masking/tags.
* *B*: + SPCS Jobs/Services for custom training/serving; Streamlit UI unchanged; features & forecasts remain in SF.
* *C*: SF as system of record + data exchange; no change to governance of tables; external model training.

---

## 5) Promising Shortlist (2–3)

### A) Snowflake‑first App

**Reference architecture**

```mermaid
flowchart LR
  subgraph Snowflake
    DT[Dynamic Tables]
    FS[(Feature Views)]
    MF[[SNOWFLAKE.ML.FORECAST]]
    FT[(Forecast Table)]
    App[[Streamlit App]]
  end
  Ingest[[Batch ingest/ELT]]-->DT-->FS-->MF-->FT-->App
```

**Bill of materials**: Warehouses (XS/S), Dynamic Tables, Tasks, Forecast Class, Streamlit App, Secure Views, Tags & Policies.

**Lifecycle**: Ingest → Feature views → Train (monthly/weekly) → Backtest → Writeback to `FORECASTS` → Serve via views/app.

**Data contracts**: see §6. Secure views guarantee stable schemas to UI.

**Observability**: ACCOUNT\_USAGE for tasks/queries; Streamlit logs; forecast QA table with MAPE/WAPE; alerts on failures.

### B) Snowflake App + SPCS

* Same as A; replace training/inference with SPCS jobs/services; add model registry & experiment tracking table.

### C) AWS SageMaker + SPA

* Warehouses (data prep), SageMaker Pipelines/Training/Processing; Glue/Athena optional; API GW+Lambda service; SPA. Writeback contracts identical to A/B.

---

## 6) Data Contracts & Schemas

> All tables live in `ANALYTICS.LENS_*` schema family; monthly granularity first.

**Historical sales (monthly)** — `LENS_SALES_MONTHLY`

* `month_date` DATE (1st of month), `lens_type` STRING, `sku` STRING, `units` NUMBER, `revenue` NUMBER, `channel` STRING, `region` STRING (optional), `source_system` STRING, `load_ts` TIMESTAMP.

**Item taxonomy** — `LENS_ITEM_DIM`

* `lens_type` STRING (semantic), `sku` STRING (PK), `family` STRING, `material` STRING, `brand` STRING, `active_flag` BOOLEAN, `start_dt`, `end_dt`.

**Calendar/seasonality** — `CALENDAR_DIM`

* `date` DATE, `month_date` DATE, `is_month_end` BOOLEAN, `month_index` INT, `holiday_flag` BOOLEAN, `season` STRING.

**Promotions/price** — `PROMO_PRICE_FACT`

* `month_date`, `sku`, `promo_flag` BOOLEAN, `promo_depth` NUMBER, `price` NUMBER, `discount_rate` NUMBER.

**Inventory/on‑hand** — `INVENTORY_MONTHLY`

* `month_date`, `sku`, `on_hand_units` NUMBER, `stockout_flag` BOOLEAN.

**Holidays** — `HOLIDAY_DIM`

* `date`, `country`, `holiday_name`, `weight` NUMBER (optional effect size).

**Forecasts (point + intervals)** — `FORECASTS`

* `run_id` STRING, `generated_ts` TIMESTAMP, `series_key` VARIANT (e.g., `["NATIONAL", "<lens_type>"]`), `lens_type` STRING, `sku` STRING NULL, `horizon_month` DATE, `forecast` NUMBER, `lower_pi` NUMBER, `upper_pi` NUMBER, `pi_level` FLOAT DEFAULT 0.95, `method` STRING, `model_ver` STRING, `features_hash` STRING.

**Alternative quantile schema** — `FORECASTS_Q`

* `run_id`, `lens_type`, `horizon_month`, `q` FLOAT (e.g., 0.1, 0.5, 0.9), `yhat` NUMBER.

**Contracts**: backward‑compatible adds only (new nullable columns); views expose stable columns to UIs; PI columns required.

---

## 7) Modeling Approach Notes

**Families**

* *Classical TS*: ARIMA/ETS, Prophet; fast baselines; seasonality handling.
* *ML*: GBM/LightGBM, CatBoost with calendar/promos; handles covariates; requires backfill of future features for horizon.
* *Hybrid/Hierarchical*: top‑down/bottom‑up reconciliation across SKU → lens\_type → national; probabilistic outputs via quantiles.

**Uncertainty**: produce 95% PI or quantiles (0.1/0.5/0.9). Visualize fan charts.

**Backtesting**: rolling origin (monthly), windows = 6–12; metrics = MAPE/WAPE/MASE; store per‑run metrics in `FORECAST_QA`.

**Cold‑start SKUs**: borrow strength via lens\_type aggregates, similarity features (taxonomy), shrinkage priors or pooled models.

**Cadence**: refresh monthly (national), optional weekly for ops; retrain full model each run; cache latest forecasts.

**Hyper‑param search**: coarse grid or Bayesian (if using SPCS/SM); cap cost via small warehouses, pruning on WAPE.

---

## 8) UX & Reporting

**UI options**: Sheets Add‑on, Streamlit in Snowflake, Snowsight dashboard, SPA (S3/CloudFront), AppSheet, Retool, QuickSight.

**Interactions**: Lens type selector, horizon picker (months ahead), unit toggle (units/revenue), dynamic chart (line w/ fan), CSV/Sheets export, print layout, accessibility (keyboard nav, ARIA), locale = JP/EN.

**Print/export**: App button exports current slice; scheduled PDF to Drive; CSV/Excel download; Sheets sync tab for analysts.

---

## 9) Security, IAM & Compliance

* **SSO**: Google Workspace as IdP to Snowflake (SAML/OIDC). QuickSight → Snowflake via OAuth client credentials. SPA → Cognito (federated to Google) + Snowflake External OAuth for service access.
* **Least privilege**: role per subsystem; views only to UI roles; mask PII with tags; row access for regional scopes.
* **Auditability**: ACCOUNT\_USAGE task/query history; application logs; change data via Streams; artifact hashes.
* **Secrets**: Snowflake Secrets, AWS Secrets Manager; avoid embedding creds; rotate.

---

## 10) Build vs Buy

* **Buy/Managed**: In‑database forecasting (Snowflake ML) or low‑code (SageMaker Canvas). Pros: speed, lower ops. Cons: algorithm control & portability.
* **Build**: Custom SPCS/SageMaker modeling for hierarchical/probabilistic and advanced evaluation.
* **Migration paths**: Start with in‑DB forecasts → graduate hot series to SPCS or SageMaker; UI unchanged; storage contract stable.

---

## 11) ADR Pack (sample)

**ADR‑001: Compute Location = Inside Snowflake (initial)**
Decision: Use SNOWFLAKE.ML.FORECAST + Tasks.
Trade‑offs: +Speed, +Governance, −Algorithm control.
Fallback: Switch training to SPCS (Option 2).

**ADR‑002: Serving Pattern = Forecast Table + Secure Views**
Decision: No online features initially; cache latest run per series; expose via views.
Fallback: Add API (Option 6) later; keep views for BI.

**ADR‑003: UI Surface = Streamlit in Snowflake**
Decision: Native app for interactivity + auth simplicity.
Fallback: Switch to SPA; reuse views & contracts.

**ADR‑004: Uncertainty Method = Prediction Intervals (95%)**
Decision: Use built‑in PI or model quantiles; render fan chart.
Fallback: Quantile regression (SPCS) if needed.

---

## 12) Roadmap & Rollout

**Phase 0 — Spike (2–3 weeks)**

* Stand up schemas, one lens type, baseline forecast with SNOWFLAKE.ML.FORECAST; Streamlit prototype with selector + chart; backtesting harness; success = WAPE < 15% for national.

**Phase 1 — MVP (1–2 lens types)**

* Dynamic Tables for features; Tasks for monthly refresh; forecast writeback + intervals; CSV/print; QA dashboard; IAM hardened.

**Phase 2 — Full Catalog + Variants**

* Add all lens types; optional regional & weekly variants; consider SPCS models for hierarchical reconciliation; add SPA or QuickSight if broader audience; observability SLIs (latency, freshness, error rate).

**Risks & Mitigations**

* *Model drift*: backtesting guardrails, alerts; retrain schedule.
* *Governance gaps*: enforce tags/masking; CI tests on views.
* *Cost creep*: resource monitors; warehouse sizing; prune features.

---

## 13) Appendix

**Glossary**: WAPE/MASE, PI, series key, SPCS, UDF/UDTF, Dynamic Table, External Function, Secure View.

**RACI (excerpt)**

* **Product**: scope, UX
* **Data Eng**: ingest, features
* **ML**: modeling, backtests
* **Platform**: IAM, observability

**Cost worksheet (knobs)**

* Warehouse sizes (XS/S/M), task cadence (monthly/weekly), SPCS pool hours, QuickSight reader count, SPA hosting (GB transfer), connector licensing.

**References**: see chat message accompanying this document for clickable links & publication dates.
